import { BaseEntity } from "../../shared/BaseEntity";
import { ValidationError } from "../../shared/DomainErrors";

export interface TaskProps {
  id: number;
  title: string;
  description?: string | undefined;
  completed: boolean;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Task entity representing a task in the domain
 */
export class Task extends BaseEntity {
  private _title: string;
  private _description: string | undefined;
  private _completed: boolean;
  private _createdAt: Date;
  private _updatedAt: Date;

  constructor(props: TaskProps) {
    super(props.id);
    this.validateTitle(props.title);

    this._title = props.title;
    this._description = props.description;
    this._completed = props.completed;
    this._createdAt = props.createdAt;
    this._updatedAt = props.updatedAt;
  }

  get title(): string {
    return this._title;
  }

  get description(): string | undefined {
    return this._description;
  }

  get completed(): boolean {
    return this._completed;
  }

  get createdAt(): Date {
    return this._createdAt;
  }

  get updatedAt(): Date {
    return this._updatedAt;
  }

  /**
   * Updates the task title with validation
   */
  updateTitle(title: string): void {
    this.validateTitle(title);
    this._title = title;
    this._updatedAt = new Date();
  }

  /**
   * Updates the task description
   */
  updateDescription(description: string | undefined): void {
    this._description = description;
    this._updatedAt = new Date();
  }

  /**
   * Marks the task as completed
   */
  markAsCompleted(): void {
    if (!this._completed) {
      this._completed = true;
      this._updatedAt = new Date();
    }
  }

  /**
   * Marks the task as not completed
   */
  markAsNotCompleted(): void {
    if (this._completed) {
      this._completed = false;
      this._updatedAt = new Date();
    }
  }

  /**
   * Updates the entire task with validation
   */
  update(
    title: string,
    description: string | undefined,
    completed?: boolean
  ): void {
    this.validateTitle(title);
    this._title = title;
    this._description = description;

    if (completed !== undefined) {
      this._completed = completed;
    }

    this._updatedAt = new Date();
  }

  /**
   * Validates the task title according to business rules
   */
  private validateTitle(title: string): void {
    if (!title || title.trim().length === 0) {
      throw new ValidationError(
        "title",
        "Title is required and cannot be empty"
      );
    }

    if (title.trim().length > 255) {
      throw new ValidationError("title", "Title cannot exceed 255 characters");
    }
  }

  /**
   * Creates a new Task instance
   */
  static create(title: string, description: string | undefined): Task {
    const now = new Date();
    return new Task({
      id: 0, // Will be generated by the repository
      title: title.trim(),
      description: description?.trim(),
      completed: false,
      createdAt: now,
      updatedAt: now,
    });
  }

  /**
   * Reconstructs a Task from persistence data
   */
  static fromPersistence(props: TaskProps): Task {
    return new Task(props);
  }

  /**
   * Converts the task to a plain object for persistence
   */
  toPersistence(): TaskProps {
    return {
      id: this.id,
      title: this._title,
      description: this._description,
      completed: this._completed,
      createdAt: this._createdAt,
      updatedAt: this._updatedAt,
    };
  }
}
